// Disclaimer: the backbone and some tests in this class are generated by Google Gemini 2.5 Pro, and double-checked and further developed by Tony.

// file_handler_test.cc
#include "gtest/gtest.h"
#include "file_handler.h"
#include "http_request.h"
#include "http_response.h"
#include <filesystem>
#include <fstream>
#include <unordered_set>

namespace fs = std::filesystem;

class FileHandlerTest : public ::testing::Test {
protected:
    std::string test_dir_;
    std::string route_prefix_;
    
    void SetUp() override {
        // Create a temporary test directory
        test_dir_ = "./test_files";
        route_prefix_ = "/static";
        
        fs::create_directories(test_dir_);
        
        // Create test files
        create_test_file("index.html", "<html><body>Hello World</body></html>");
        create_test_file("style.css", "body { color: red; }");
        create_test_file("script.js", "console.log('test');");
        create_test_file("image.png", "fake_png_data");
        create_test_file("document.txt", "Plain text content");
        create_test_file("data.json", "{\"key\": \"value\"}");
        create_test_file("unsupported.xyz", "unsupported file type");
        
        // Create a subdirectory with a file
        fs::create_directories(test_dir_ + "/subdir");
        create_test_file("subdir/nested.html", "<html>Nested</html>");
    }
    
    void TearDown() override {
        // Clean up test directory
        fs::remove_all(test_dir_);
    }
    
    void create_test_file(const std::string& relative_path, const std::string& content) {
        std::string full_path = test_dir_ + "/" + relative_path;
        std::ofstream file(full_path);
        file << content;
        file.close();
    }
    
    HttpRequest create_request(const std::string& path) {
        HttpRequest request;
        request.set_method("GET");
        request.set_path(path);
        request.set_version("HTTP/1.1");
        return request;
    }
};

// Test: Constructor with valid directory
TEST_F(FileHandlerTest, ConstructorValidDirectory) {
    EXPECT_NO_THROW({
        FileHandler handler(test_dir_, route_prefix_);
    });
}

// Test: Constructor with invalid directory
TEST_F(FileHandlerTest, ConstructorInvalidDirectory) {
    EXPECT_THROW({
        FileHandler handler("/nonexistent/path", route_prefix_);
    }, std::invalid_argument);
}

// Test: Constructor with file instead of directory
TEST_F(FileHandlerTest, ConstructorFileNotDirectory) {
    std::string file_path = test_dir_ + "/notadir.txt";
    create_test_file("notadir.txt", "content");
    
    EXPECT_THROW({
        FileHandler handler(file_path, route_prefix_);
    }, std::invalid_argument);
}

// Test: Constructor with custom extensions
TEST_F(FileHandlerTest, ConstructorCustomExtensions) {
    std::unordered_set<std::string> custom_exts = {".html", ".css"};
    EXPECT_NO_THROW({
        FileHandler handler(test_dir_, route_prefix_, custom_exts);
    });
}

// Test: Serve HTML file successfully
TEST_F(FileHandlerTest, ServeHtmlFile) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/index.html");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 200);
    EXPECT_EQ(response.get_reason_phrase(), "OK");
    EXPECT_EQ(response.get_header("Content-Type"), "text/html");
    EXPECT_EQ(response.get_message_body(), "<html><body>Hello World</body></html>");
}

// Test: Serve CSS file successfully
TEST_F(FileHandlerTest, ServeCssFile) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/style.css");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 200);
    EXPECT_EQ(response.get_header("Content-Type"), "text/css");
    EXPECT_EQ(response.get_message_body(), "body { color: red; }");
}

// Test: Serve JavaScript file successfully
TEST_F(FileHandlerTest, ServeJavaScriptFile) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/script.js");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 200);
    EXPECT_EQ(response.get_header("Content-Type"), "application/javascript");
    EXPECT_EQ(response.get_message_body(), "console.log('test');");
}

// Test: Serve JSON file successfully
TEST_F(FileHandlerTest, ServeJsonFile) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/data.json");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 200);
    EXPECT_EQ(response.get_header("Content-Type"), "application/json");
    EXPECT_EQ(response.get_message_body(), "{\"key\": \"value\"}");
}

// Test: Serve text file successfully
TEST_F(FileHandlerTest, ServeTextFile) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/document.txt");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 200);
    EXPECT_EQ(response.get_header("Content-Type"), "text/plain");
    EXPECT_EQ(response.get_message_body(), "Plain text content");
}

// Test: File not found returns 404
TEST_F(FileHandlerTest, FileNotFound) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/nonexistent.html");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 404);
    EXPECT_EQ(response.get_reason_phrase(), "Not Found");
    EXPECT_EQ(response.get_header("Content-Type"), "text/html");
}

// Test: Unsupported file type returns 415
TEST_F(FileHandlerTest, UnsupportedFileType) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/unsupported.xyz");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 415);
    EXPECT_EQ(response.get_reason_phrase(), "Unsupported Media Type");
    EXPECT_EQ(response.get_header("Content-Type"), "text/plain");
}

// Test: Custom extensions - allowed file
TEST_F(FileHandlerTest, CustomExtensionsAllowed) {
    std::unordered_set<std::string> custom_exts = {".html", ".txt"};
    FileHandler handler(test_dir_, route_prefix_, custom_exts);
    
    HttpRequest request = create_request("/static/index.html");
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 200);
}

// Test: Custom extensions - blocked file
TEST_F(FileHandlerTest, CustomExtensionsBlocked) {
    std::unordered_set<std::string> custom_exts = {".html", ".txt"};
    FileHandler handler(test_dir_, route_prefix_, custom_exts);
    
    HttpRequest request = create_request("/static/style.css");
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 415);
}

// Test: Serve file from subdirectory
TEST_F(FileHandlerTest, ServeFileFromSubdirectory) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/subdir/nested.html");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 200);
    EXPECT_EQ(response.get_message_body(), "<html>Nested</html>");
}

// Test: Directory traversal attack prevention
TEST_F(FileHandlerTest, PreventDirectoryTraversal) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/../../../etc/passwd");
    
    HttpResponse response = handler.handle_request(request);
    
    // Should return 404, not access files outside root path
    EXPECT_EQ(response.get_status_code(), 404);
}

// Test: Directory traversal with multiple ..
TEST_F(FileHandlerTest, PreventMultipleDirectoryTraversal) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/../../../../../../etc/passwd");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 404);
}

// Test: Path with . components
TEST_F(FileHandlerTest, PathWithDotComponents) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/./index.html");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 200);
    EXPECT_EQ(response.get_message_body(), "<html><body>Hello World</body></html>");
}

// Test: Empty path after route prefix
TEST_F(FileHandlerTest, EmptyPathAfterPrefix) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static");
    
    HttpResponse response = handler.handle_request(request);
    
    // Should return 404 because "/" is treated as a file
    EXPECT_EQ(response.get_status_code(), 404);
}

// Test: Case sensitivity in file names
TEST_F(FileHandlerTest, CaseSensitiveFileNames) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/INDEX.HTML");
    
    HttpResponse response = handler.handle_request(request);
    
    // Behavior depends on filesystem case sensitivity:
    // - Case-sensitive filesystems (Linux): returns 404
    // - Case-insensitive filesystems (macOS, Windows): returns 200
    // Check if the filesystem is case-insensitive by testing if INDEX.HTML exists
    std::string test_path = test_dir_ + "/INDEX.HTML";
    bool case_insensitive = std::filesystem::exists(test_path);
    
    if (case_insensitive) {
        EXPECT_EQ(response.get_status_code(), 200);
    } else {
        EXPECT_EQ(response.get_status_code(), 404);
    }
}

// Test: MIME type for HTML
TEST_F(FileHandlerTest, MimeTypeHtml) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/index.html");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_header("Content-Type"), "text/html");
}

// Test: MIME type case insensitive (.HTML)
TEST_F(FileHandlerTest, MimeTypeCaseInsensitive) {
    create_test_file("upper.HTML", "<html>Upper</html>");
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/upper.HTML");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 200);
    EXPECT_EQ(response.get_header("Content-Type"), "text/html");
}

// Test: Different route prefix
TEST_F(FileHandlerTest, DifferentRoutePrefix) {
    FileHandler handler(test_dir_, "/files");
    HttpRequest request = create_request("/files/index.html");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 200);
    EXPECT_EQ(response.get_message_body(), "<html><body>Hello World</body></html>");
}

// Test: Root path with trailing slash
TEST_F(FileHandlerTest, RootPathWithTrailingSlash) {
    std::string path_with_slash = test_dir_ + "/";
    FileHandler handler(path_with_slash, route_prefix_);
    HttpRequest request = create_request("/static/index.html");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 200);
}

// Test: Large file handling
TEST_F(FileHandlerTest, LargeFile) {
    std::string large_content(10000, 'A');
    create_test_file("large.txt", large_content);
    
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/large.txt");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 200);
    EXPECT_EQ(response.get_message_body().length(), 10000);
}

// Test: Empty file
TEST_F(FileHandlerTest, EmptyFile) {
    create_test_file("empty.txt", "");
    
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/empty.txt");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 200);
    EXPECT_EQ(response.get_message_body(), "");
}

// Test: Path with query string parameters
TEST_F(FileHandlerTest, PathWithQueryString) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/index.html?param=value");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 200);
    EXPECT_EQ(response.get_message_body(), "<html><body>Hello World</body></html>");
}

// Test: Path with multiple query parameters
TEST_F(FileHandlerTest, PathWithMultipleQueryParameters) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/style.css?version=1.0&cache=false");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 200);
    EXPECT_EQ(response.get_header("Content-Type"), "text/css");
    EXPECT_EQ(response.get_message_body(), "body { color: red; }");
}

// Test: Path with empty query string
TEST_F(FileHandlerTest, PathWithEmptyQueryString) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/document.txt?");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 200);
    EXPECT_EQ(response.get_message_body(), "Plain text content");
}

// Test: Query string doesn't affect file not found
TEST_F(FileHandlerTest, QueryStringWithNonexistentFile) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/missing.html?param=value");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 404);
    EXPECT_EQ(response.get_reason_phrase(), "Not Found");
}

// Test: Query string with subdirectory path
TEST_F(FileHandlerTest, QueryStringWithSubdirectory) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/subdir/nested.html?refresh=true");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 200);
    EXPECT_EQ(response.get_message_body(), "<html>Nested</html>");
}

// Test: Query string doesn't bypass unsupported file type check
TEST_F(FileHandlerTest, QueryStringWithUnsupportedFileType) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/unsupported.xyz?force=true");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 415);
    EXPECT_EQ(response.get_reason_phrase(), "Unsupported Media Type");
}

// Test: Query string with fragment identifier (though fragments shouldn't be sent to server)
TEST_F(FileHandlerTest, PathWithQueryAndFragment) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/index.html?section=intro#header");
    
    HttpResponse response = handler.handle_request(request);
    
    // Should still work - the query string (and anything after) is stripped
    EXPECT_EQ(response.get_status_code(), 200);
    EXPECT_EQ(response.get_message_body(), "<html><body>Hello World</body></html>");
}

// Test: Query string with equals sign but no value
TEST_F(FileHandlerTest, QueryStringWithNoValue) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/script.js?debug=");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 200);
    EXPECT_EQ(response.get_header("Content-Type"), "application/javascript");
}

// Test: Query string that looks like directory traversal
TEST_F(FileHandlerTest, QueryStringWithTraversalAttempt) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/index.html?path=../../etc/passwd");
    
    HttpResponse response = handler.handle_request(request);
    
    // Query string should be ignored, file should be served normally
    EXPECT_EQ(response.get_status_code(), 200);
    EXPECT_EQ(response.get_message_body(), "<html><body>Hello World</body></html>");
}

// Test: Very long query string
TEST_F(FileHandlerTest, VeryLongQueryString) {
    FileHandler handler(test_dir_, route_prefix_);
    std::string long_query(1000, 'x');
    HttpRequest request = create_request("/static/document.txt?" + long_query);
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 200);
    EXPECT_EQ(response.get_message_body(), "Plain text content");
}

// Test: Query string with only question mark at end
TEST_F(FileHandlerTest, OnlyQuestionMark) {
    FileHandler handler(test_dir_, route_prefix_);
    HttpRequest request = create_request("/static/image.png?");
    
    HttpResponse response = handler.handle_request(request);
    
    EXPECT_EQ(response.get_status_code(), 200);
    EXPECT_EQ(response.get_header("Content-Type"), "image/png");
}