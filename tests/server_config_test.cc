// Disclaimer: the backbone and some tests in this class are generated by Google Gemini 2.5 Pro, and double-checked and further developed by Tony.

#include "gtest/gtest.h"
#include "server_config.h"  // Your header file
#include "config_parser.h"    // The NginxConfig parser header
#include <memory>

// Test fixture for ServerConfig tests
class ServerConfigTest : public ::testing::Test {
protected:
    // Helper function to create a statement
    // This simulates the parser's output
    std::shared_ptr<NginxConfigStatement> CreateStatement(const std::vector<std::string>& tokens) {
        auto stmt = std::make_shared<NginxConfigStatement>();
        stmt->tokens_ = tokens;
        return stmt;
    }

    ServerConfig server_config_; // The object under test
    NginxConfig mock_config_;    // The mock config to parse
};

// Test parsing a simple, valid configuration
TEST_F(ServerConfigTest, SimpleValidConfig) {
    // server {
    //   listen 9090;
    //   location /static {
    //     handler Static;
    //     root /var/www;
    //   }
    // }
    auto server_block_stmt = CreateStatement({"server"});
    server_block_stmt->child_block_ = std::make_unique<NginxConfig>();
    
    // Add listen
    server_block_stmt->child_block_->statements_.push_back(CreateStatement({"listen", "9090"}));
    
    // Add location
    auto location_stmt = CreateStatement({"location", "/static"});
    location_stmt->child_block_ = std::make_unique<NginxConfig>();
    location_stmt->child_block_->statements_.push_back(CreateStatement({"handler", "Static"}));
    location_stmt->child_block_->statements_.push_back(CreateStatement({"root", "/var/www"}));
    server_block_stmt->child_block_->statements_.push_back(location_stmt);

    // Add the server block to the main config
    mock_config_.statements_.push_back(server_block_stmt);

    bool success = server_config_.load_from_nginx_config(mock_config_);

    EXPECT_TRUE(success);
    EXPECT_EQ(server_config_.get_port(), 9090); // Port is overridden
    
    const auto& routes = server_config_.get_routes();
    EXPECT_EQ(routes.size(), 1);
    EXPECT_TRUE(routes.count("/static"));
    
    const auto& handler = routes.at("/static");
    EXPECT_EQ(handler.type, "Static");
    EXPECT_EQ(handler.settings.size(), 1);
    EXPECT_EQ(handler.settings.at("root"), "/var/www");
}

// Test that the server uses the default port (8080) if not specified
TEST_F(ServerConfigTest, UsesDefaultPort) {
    // server {
    //   location / {
    //     handler Echo;
    //   }
    // }
    auto server_block_stmt = CreateStatement({"server"});
    server_block_stmt->child_block_ = std::make_unique<NginxConfig>();

    // No 'listen' directive
    
    // Add location
    auto location_stmt = CreateStatement({"location", "/"});
    location_stmt->child_block_ = std::make_unique<NginxConfig>();
    location_stmt->child_block_->statements_.push_back(CreateStatement({"handler", "Echo"}));
    server_block_stmt->child_block_->statements_.push_back(location_stmt);

    mock_config_.statements_.push_back(server_block_stmt);
    
    bool success = server_config_.load_from_nginx_config(mock_config_);
    
    EXPECT_TRUE(success);
    EXPECT_EQ(server_config_.get_port(), 8080); // Port remains at default
}

// Test multiple location blocks
TEST_F(ServerConfigTest, MultipleLocations) {
    // server {
    //   listen 80;
    //   location /static { ... }
    //   location /api { ... }
    // }
    auto server_block_stmt = CreateStatement({"server"});
    server_block_stmt->child_block_ = std::make_unique<NginxConfig>();

    server_block_stmt->child_block_->statements_.push_back(CreateStatement({"listen", "80"}));
    
    // location /static { ... }
    auto static_loc = CreateStatement({"location", "/static"});
    static_loc->child_block_ = std::make_unique<NginxConfig>();
    static_loc->child_block_->statements_.push_back(CreateStatement({"handler", "Static"}));
    server_block_stmt->child_block_->statements_.push_back(static_loc);

    // location /api { ... }
    auto api_loc = CreateStatement({"location", "/api"});
    api_loc->child_block_ = std::make_unique<NginxConfig>();
    api_loc->child_block_->statements_.push_back(CreateStatement({"handler", "Api"}));
    server_block_stmt->child_block_->statements_.push_back(api_loc);

    mock_config_.statements_.push_back(server_block_stmt);

    bool success = server_config_.load_from_nginx_config(mock_config_);

    EXPECT_TRUE(success);
    EXPECT_EQ(server_config_.get_port(), 80);
    EXPECT_EQ(server_config_.get_routes().size(), 2);
    EXPECT_TRUE(server_config_.get_routes().count("/static"));
    EXPECT_TRUE(server_config_.get_routes().count("/api"));
    EXPECT_EQ(server_config_.get_routes().at("/api").type, "Api");
}

// Test failure when no routes are defined (but server block exists)
TEST_F(ServerConfigTest, MissingRoutes) {
    // server {
    //   listen 8080;
    // }
    auto server_block_stmt = CreateStatement({"server"});
    server_block_stmt->child_block_ = std::make_unique<NginxConfig>();
    
    server_block_stmt->child_block_->statements_.push_back(CreateStatement({"listen", "8080"}));
    
    // No location blocks...
    mock_config_.statements_.push_back(server_block_stmt);

    bool success = server_config_.load_from_nginx_config(mock_config_);
    EXPECT_FALSE(success); // Fails because routes are empty
    EXPECT_TRUE(server_config_.get_routes().empty());
}

// Test failure on invalid (non-numeric) port
TEST_F(ServerConfigTest, InvalidPort) {
    // server {
    //   listen not-a-number;
    //   location /static { ... }
    // }
    auto server_block_stmt = CreateStatement({"server"});
    server_block_stmt->child_block_ = std::make_unique<NginxConfig>();

    server_block_stmt->child_block_->statements_.push_back(CreateStatement({"listen", "not-a-number"}));
    
    auto location_stmt = CreateStatement({"location", "/static"});
    location_stmt->child_block_ = std::make_unique<NginxConfig>();
    location_stmt->child_block_->statements_.push_back(CreateStatement({"handler", "Static"}));
    server_block_stmt->child_block_->statements_.push_back(location_stmt);

    mock_config_.statements_.push_back(server_block_stmt);

    bool success = server_config_.load_from_nginx_config(mock_config_);
    EXPECT_FALSE(success);
}

// Test failure when no server block is found
TEST_F(ServerConfigTest, NoServerBlock) {
    // Top-level statements, but no 'server' block
    mock_config_.statements_.push_back(CreateStatement({"listen", "8080"}));
    
    auto location_stmt = CreateStatement({"location", "/static"});
    location_stmt->child_block_ = std::make_unique<NginxConfig>();
    location_stmt->child_block_->statements_.push_back(CreateStatement({"handler", "Static"}));
    mock_config_.statements_.push_back(location_stmt);

    // The parser should fail because it expects a 'server' block
    bool success = server_config_.load_from_nginx_config(mock_config_);
    EXPECT_FALSE(success);
}

// Test location block with no child (e.g., "location /static;")
TEST_F(ServerConfigTest, LocationWithNoChildBlock) {
    // server {
    //   listen 8080;
    //   location /static;
    // }
    auto server_block_stmt = CreateStatement({"server"});
    server_block_stmt->child_block_ = std::make_unique<NginxConfig>();

    server_block_stmt->child_block_->statements_.push_back(CreateStatement({"listen", "8080"}));
    
    auto location_stmt = CreateStatement({"location", "/static"});
    location_stmt->child_block_ = nullptr; // No child block
    server_block_stmt->child_block_->statements_.push_back(location_stmt);

    mock_config_.statements_.push_back(server_block_stmt);

    // The 'if (statement->child_block_)' check fails, no route is added
    bool success = server_config_.load_from_nginx_config(mock_config_);
    EXPECT_FALSE(success); // Fails because routes are empty
    EXPECT_TRUE(server_config_.get_routes().empty());
}

// Test location statement with missing path (e.g., "location;")
TEST_F(ServerConfigTest, LocationMissingPath) {
    // server {
    //   listen 8080;
    //   location;
    // }
    auto server_block_stmt = CreateStatement({"server"});
    server_block_stmt->child_block_ = std::make_unique<NginxConfig>();

    server_block_stmt->child_block_->statements_.push_back(CreateStatement({"listen", "8080"}));
    
    auto location_stmt = CreateStatement({"location"}); // size < 2
    location_stmt->child_block_ = std::make_unique<NginxConfig>();
    server_block_stmt->child_block_->statements_.push_back(location_stmt);

    mock_config_.statements_.push_back(server_block_stmt);

    // The 'if (statement->tokens_.size() >= 2)' check fails
    bool success = server_config_.load_from_nginx_config(mock_config_);
    EXPECT_FALSE(success); // Fails because routes are empty
    EXPECT_TRUE(server_config_.get_routes().empty());
}
